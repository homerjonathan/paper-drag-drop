<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-iconset-svg/iron-iconset-svg.html">
<!--

Paper Drag Drop -

Based On Component By (But extensively changed now):

  Copyright (c) 2014 Wassim Chegham. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt

Icons From:

  Many Great Icons are provided by the Google Polymer Team - Just embedded for quick download. Under BSD style license
  See - https://github.com/PolymerElements/iron-icons/blob/master/iron-icons.html
  Copyright (c) 2014 The Polymer Project Authors. All rights reserved.

-->

<!--
Element that enables any DOM element to be draggable and resizable.
##### Example
    <drag-resize></drag-resize>
@element paper-drag-drop
@blurb Element that enables any DOM element to be draggable and resizable.
@status beta
@homepage https://github.io/manekinekko/drag-resize
@demo demo/index.html
-->
<dom-module id="paper-drag-drop">
  <template>
    <style>
      .drag-elastic-band {
        border: 1px dotted rgb(8, 253, 25);
        display: none;
        position: absolute;
      }
      .drag-resize-selected {
        border: 1px dotted rgb(0, 150, 253);
        cursor: move;
        display: block;
        width: 100%;
        height: 100%;
        position: absolute;
        z-index: 999;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
      }
      .drag-resize-handlers {
        position: absolute;
        width: 8px;
        height: 8px;
        font-size: 1px;
        background: rgb(0, 150, 253);
        -webkit-transition: all 0.1s linear;
        transition: all 0.1s linear;
        opacity: 1;
        border-radius: 5px;
        border: 0px solid black;
      }
      :host(.drag-resize-selected) .drag-resize-handlers {
        opacity: 1;
      }
      .drag-resize-handlers:hover {
        transform: scale(1.6); /*chrome*/
        -webkit-transform: scale(1.6); /*nodewebkit*/
        border: 1px solid black;
      }
      /*
       Individual corner classes - required for resize support.
      */
      .drag-resize-handlers[data-direction="tl"] {
        top: -5px;
        left: -5px;
        cursor: nw-resize;
      }
      .drag-resize-handlers[data-direction="tm"] {
        top: -5px;
        left: 50%;
        margin-left: -5px;
        cursor: n-resize;
      }
      .drag-resize-handlers[data-direction="tr"] {
        top: -5px;
        right: -5px;
        cursor: ne-resize;
      }
      .drag-resize-handlers[data-direction="ml"] {
        top: 50%;
        margin-top: -5px;
        left: -5px;
        cursor: w-resize;
      }
      .drag-resize-handlers[data-direction="mr"] {
        top: 50%;
        margin-top: -5px;
        right: -5px;
        cursor: e-resize;
      }
      .drag-resize-handlers[data-direction="bl"] {
        bottom: -5px;
        left: -5px;
        cursor: sw-resize;
      }
      .drag-resize-handlers[data-direction="bm"] {
        bottom: -5px;
        left: 50%;
        margin-left: -5px;
        cursor: s-resize;
      }
      .drag-resize-handlers[data-direction="br"] {
        bottom: -5px;
        right: -5px;
        cursor: se-resize;
      }
      .hidden {
        display: none;
      }
    </style>
    <div id="drag-elastic-band" class="drag-elastic-band"></div>
    <iron-iconset-svg name="paperdragdrop" size="24">
      <svg><defs>
        <g id="content-copy"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></g>
        <g id="content-cut"><path d="M9.64 7.64c.23-.5.36-1.05.36-1.64 0-2.21-1.79-4-4-4S2 3.79 2 6s1.79 4 4 4c.59 0 1.14-.13 1.64-.36L10 12l-2.36 2.36C7.14 14.13 6.59 14 6 14c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4c0-.59-.13-1.14-.36-1.64L12 14l7 7h3v-1L9.64 7.64zM6 8c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm0 12c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm6-7.5c-.28 0-.5-.22-.5-.5s.22-.5.5-.5.5.22.5.5-.22.5-.5.5zM19 3l-6 6 2 2 7-7V3z"/></g>
        <g id="content-paste"><path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"/></g>
        <g id="vertical-align-bottom"><path d="M16 13h-3V3h-2v10H8l4 4 4-4zM4 19v2h16v-2H4z"/></g>
        <g id="vertical-align-center"><path d="M8 19h3v4h2v-4h3l-4-4-4 4zm8-14h-3V1h-2v4H8l4 4 4-4zM4 11v2h16v-2H4z"/></g>
        <g id="vertical-align-top"><path d="M8 11h3v10h2V11h3l-4-4-4 4zM4 3v2h16V3H4z"/></g>
        <g id="undo"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/></g>
        <g id="delete"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></g>
      </defs></svg>
    </iron-iconset-svg>
    <div id="resizable_handlers">
      <template id="selectedelements" is="dom-repeat" items="{{selectedElements}}">
        <div id="{{item.name}}" class="drag-resize-selected" on-track="_eventOnTrack" >
          <div class="drag-resize-handlers" data-direction="tl"></div>
          <div class="drag-resize-handlers" data-direction="tm"></div>
          <div class="drag-resize-handlers" data-direction="tr"></div>
          <div class="drag-resize-handlers" data-direction="mr"></div>
          <div class="drag-resize-handlers" data-direction="ml"></div>
          <div class="drag-resize-handlers" data-direction="bl"></div>
          <div class="drag-resize-handlers" data-direction="bm"></div>
          <div class="drag-resize-handlers" data-direction="br"></div>
        </div>
      </template>
    </div>
  </template>
</dom-module>
<!--
-->
<script>
    class PaperDragDrop extends Polymer.GestureEventListeners(Polymer.Element) {
        static get is() { return 'paper-drag-drop'; }
        static get properties() { return {
            selectedElements: {
                type: Array,
                notify: true,
                value: []
            },
            menuAddObjects: {
                type: Array,
                notify: true,
                observer: "_doMenu"
            },
            aspectRatio: {
                /**
                 * `aspectRatio` is a property that preserves the aspectRatio.
                 *
                 * @property aspectRatio
                 * @type bool
                 * @default false
                 */
                type: Boolean,
                value: false
            },
            /**
             * `minWidth` is the minimum pixel width of the element.
             *
             * @property minWidth
             * @type number
             * @default 30
             */
            minWidth: {
                type: Number,
                value: 10
            },
            /**
             * `minHeight` is the minimum pixel height of the element.
             *
             * @property minHeight
             * @type number
             * @default 30
             */
            minHeight: {
                type: Number,
                value: 10
            },
            /**
             * `minLeft` is the minimum left position, in pixels.
             *
             * @property minLeft
             * @type number
             * @default -9999
             */
            minLeft: {
                type: Number,
                value: -9999
            },
            /**
             * `maxLeft` is the maximum left position, in pixels.
             *
             * @property maxLeft
             * @type number
             * @default 9999
             */
            maxLeft: {
                type: Number,
                value: 9999
            },
            /**
             * `minTop` is the minimum top position, in pixels.
             *
             * @property minTop
             * @type number
             * @default -9999
             */
            minTop: {
                type: Number,
                value: -9999
            },
            /**
             * `maxTop` is the minimum top position, in pixels.
             *
             * @property maxTop
             * @type number
             * @default 9999
             */
            maxTop: {
                type: Number,
                value: 9999
            },
            /**
             * `zoomRatio` is the zoom ratio used to scale the element.
             *
             * @property zoomRatio
             * @type number
             * @default 1
             */
            zoomRatio: {
                type: Number,
                value: 1
            },
            /**
             * `zoomLevel` is the original zoom level.
             *
             * @property zoomLevel
             * @type number
             * @default 1
             */
            zoomLevel: {
                type: Number,
                value: 1
            },
            class: {
                type: String,
                value: "drag-resize",
                reflectToAttribute: true
            },
            dragdroparea: {
                type: String,
                value: "paper-drag-drop-zone"
            },
            baseobject: {
                type: String,
                value: "$"
            }
        }
        }
        constructor() {
            super();
            this.selectedElement = null;
            this.resizeHandle = null;
            this.enable = true;
            this.bbox = {
                elmX: 0,
                elmY: 0,
                elmH: 0,
                elmW: 0
            };
            this.mouse = {
                x: 0,
                y: 0,
                last: {
                    x: 0,
                    y: 0
                },
                offset: {
                    x: 0,
                    y: 0
                }
            };

            this.menuAddObjects = [];

            // Can Be Automated this....
            // this.menuAddObjects = [
            //     {type: "add", description: "Add Label", command: "add-label"},
            //     {type: "add", description: "Add Image", command: "add-image"},
            //     {type: "add", description: "Add Button", command: "add-button"}
            // ];
            this._doMenu();
            this._Bind_EventMouseDown = this._EventMouseDown.bind(this);
            this._Bind_EventContextMenu = this._EventContextMenu.bind(this);
            this._Bind_EventRefreshOverlays = this._EventRefreshOverlays.bind(this);
            this._Bind_EventRefocus = this._EventRefocus.bind(this);
        }
        _doMenu() {
            this.menuData = [
                {
                    type: "align", description: "Align", command: "",
                    submenu: [
                        {type: "align", description: "Left", command: "edit-Align", subcommand:"Left",icon: "paperdragdrop:"},
                        {type: "align", description: "Right", command: "edit-Align",subcommand:"Right",icon: "paperdragdrop:content-copy"},
                        {type: "align", description: "Top", command: "edit-Align",subcommand:"Top",icon: "paperdragdrop:vertical-align-top"},
                        {type: "align", description: "Bottom", command: "edit-Align",subcommand:"Bottom",icon: "paperdragdrop:vertical-align-bottom"},
                        {type: "align", description: "Vertical Center", command: "edit-Align",subcommand:"Vertical",icon: "paperdragdrop:vertical-align-center"},
                        {type: "align", description: "Horizontal Center", command: "edit-Align",subcommand:"Horizontal",icon: "paperdragdrop:vertical-align-center"}
                    ]
                },
                {
                    type: "align", description: "Resize", command: "", icon:"arrow-drop-down",
                    submenu: [
                        {type: "align", description: "Grow to Largest Width", command: "edit-Resize", subcommand:"GrowWidth"},
                        {type: "align", description: "Shrink to Smallest Width", command: "edit-Resize", subcommand:"ShrinkWidth"},
                        {type: "align", description: "Grow to Largest Height", command: "edit-Resize", subcommand:"GrowHeight"},
                        {type: "align", description: "Shrink to Smallest Height", command: "edit-Resize", subcommand:"ShrinkHeight"}
                    ]
                },
                {type: "add", description: "Add", command: "",submenu: this.menuAddObjects},
                {type: "add", description: "-", command: ""},
                {type: "clipboard", description: "Copy", command: "edit-Clipboard", subcommand:"Copy", icon: "paperdragdrop:content-copy"},
                {type: "clipboard", description: "Cut", command: "edit-Clipboard", subcommand:"Cut",icon: "paperdragdrop:content-cut"},
                {type: "clipboard-paste", description: "Paste", command: "edit-Clipboard", subcommand:"Paste", icon: "paperdragdrop:content-paste"},
                {type: "undo", description: "Undo", command: "edit-UndoStep",icon: "paperdragdrop:undo"},
                {type: "delete", description: "-", command: ""},
                {type: "delete", description: "Delete", command: "edit-Delete",icon: "paperdragdrop:delete"}
            ];
        }
        connectedCallback() {
            super.connectedCallback();
            // Critical to trap mouse movements
            document.addEventListener('mousedown', this._Bind_EventMouseDown);
            document.addEventListener('contextmenu', this._Bind_EventContextMenu);
            document.addEventListener('edit-RefreshOverlays', this._Bind_EventRefreshOverlays);
            document.addEventListener('edit-Refocus', this._Bind_EventRefocus);
            // Find out Drag Drop Area so we can work out where it was clicked
            if (this.dragdropareaElement == null) {
                this.dragdropareaElement = app.Poly.page.shadowRoot.querySelector('#' + this.dragdroparea);
            }
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            document.removeEventListener('mousedown', this._Bind_EventMouseDown);
            document.removeEventListener('contextmenu', this._Bind_EventContextMenu);
            document.removeEventListener('edit-RefreshOverlays', this._Bind_EventRefreshOverlays);
            document.removeEventListener('edit-Refocus', this._Bind_EventRefocus);
        }
        /**
         * This method is used to show all or a subset of the resize handlers.
         *
         * @method displayHandlers
         * @param {Array} filters An array of the handlers to show. If the array is empty or not provided, then all the handlers are shown.
         */
        displayHandlers(filters){
            var handlersContainer = this.$.resizable_handlers;
            var handlers = [].slice.call(handlersContainer.querySelectorAll('[data-direction]'));
            if(filters && filters.length>0){
                // first, hide all
                handlers.forEach(function(handler, index, self){
                    handler.style.visibility = 'hidden';
                });
                // show filtered only
                filters.map(function(filter, index, self){
                    var dom = handlersContainer.querySelector('[data-direction="'+filter+'"]');
                    if(dom){
                        dom.style.visibility = 'visible';
                    }
                    return dom;
                });
            }
            else {
                // show all
                handlers.forEach(function(handler, index, self){
                    handler.style.visibility = 'visible';
                });
            }
        }
        /**
         * The `ontap` handler.
         *
         * @method ontap
         * @param  {Event} event The `ontap` event.
         */
        ontap(event){
            event.stopPropagation();
            event.preventDefault();
        }
        //
        // Internal On Track Event
        //
        _eventOnTrack(e) {
            switch(e.detail.state) {
                case 'start':
                    this.drag(e);
                    break;
                case 'track':
                    this.dragging(e);
                    break;
                case 'end':
                    this.finishedDragging(e);
                    break;
            }
            event.stopPropagation();
            event.preventDefault();
        }
        /**
         * Focus add Element to list of Elements selected
         *
         * @method focus
         * @param  {newElement} newElement The element to be selected.
         * @param  {replace} replace Boolean to indicate if other elements selected are to be removed and replaced with this one.
         */
        focus(newElement, replace){
            // Should only be called when new item selected.  Otherwise something has gone wrong.
            if (replace === true) {
                // Clear Out Result
                this.selectedElements = [];
            }
            if ( this.enable && newElement && !newElement.classList.contains('drag-resize-selected') ) {
                // Add With Index Name - Use Polymer so it can see the request
                var elementObj = this._elementAlreadyAdded(newElement);
                // Force immediate render.  No performance issues as only human speed of clicking
                this.$.selectedelements.render();
                // Not the most elegant but...grab overlay
                var overlay = this.shadowRoot.querySelector('#'+elementObj.name);
                // Hook
                elementObj.overlay = overlay;
                // var position = this.position(newElement.$.node);
                // var dimension = this.dimension(newElement);
                var position = this.position(newElement, newElement.$.node);
                var dimension = this.dimension(newElement.$.node);
                overlay.style.width = dimension.width + 'px';
                overlay.style.height = dimension.height + 'px';
                overlay.style.left = position.left + 'px';
                overlay.style.top = position.top + 'px';
                //
                // Fire Edit Element
                //
                this.fire('edit-Element', this.selectedElements);
            }
        }
        /**
         * Blur (deselect) the active element.
         *
         * @method blur
         * @param  {DOMElement} delHandles The active element to be blured
         */
        blur(delHandles){
            console.log("Blurry Vision Detected:");
            if (delHandles) {
                if (this.dragblur) {
                    this.dragblur();
                }
            }
            if(this.selectedElement){
                this.selectedElement.selected = false;
                this.selectedElement.classList.remove('drag-resize-focus');
            }
            this.fire('edit-Cancel', null);
            this.resizeHandle = null;
            this.selectedElement = null;
            this.mouse.offset.x = 0;
            this.mouse.offset.y = 0;
            this.bbox.elmW = 0;
            this.bbox.elmH = 0;
            this.bbox.elmX = 0;
            this.bbox.elmY = 0;
        }
        /**
         * A convenient function that computes the exact position of an element.
         *
         * @method position
         * @param {DOMElement} element The element to compute.
         * @return {Object} The current top/left position of an element.
         */
        position(element, elementNode){
            // Work out offset
            var offset = this.offset(elementNode);
            return {
                top: parseInt(element.style.top) + offset.top,
                left: parseInt(element.style.left) + offset.left
            };
        }
        /**
         * A convenient function that computes the correct offset position of an element.
         *
         * @method offset
         * @param {DOMElement} element The element to compute.
         * @return {Object} The current top/left offset position of an element.
         */
        offset(element){
            var docElem;
            var o = {
                top: 0,
                left: 0
            };

            if(element) {
                // Get Computed Style
                var computedStyle = this.getComputedStyle(element);
                var iMarginLeft = Number(computedStyle.marginLeft.replace("px", "")) + Number(computedStyle.borderLeftWidth.replace("px", ""))
                    + Number(computedStyle.paddingLeft.replace("px", ""));
                var iMarginTop = Number(computedStyle.marginTop.replace("px", "")) + Number(computedStyle.borderTopWidth.replace("px", ""))
                    + Number(computedStyle.paddingTop.replace("px", ""));
                docElem = element.ownerDocument.documentElement;
                o = {
                    top: element.offsetTop - docElem.clientTop - iMarginTop,
                    left: element.offsetLeft - docElem.clientLeft - iMarginLeft
                }
            }
            return o;
        }

        /**
         * A convenient function that computes the correct dimension of an element.
         *
         * @method dimension
         * @param {DOMElement} element The element to compute.
         * @return {Object} The current width/height of an element.
         */
        dimension(element){
            function getDisplayType(element) {
                return (element.currentStyle || window.getComputedStyle(element, '')).display;
            }
            var displayType = getDisplayType(element);
            if(displayType === 'inline' || displayType === ''){
                return element.getBoundingClientRect();
            }
            else {
                var computedStyle = this.getComputedStyle(element);
                var iMarginWidth = Number(computedStyle.marginLeft.replace("px", "")) + Number(computedStyle.marginRight.replace("px", ""))
                    + Number(computedStyle.borderLeftWidth.replace("px", "")) + Number(computedStyle.borderRightWidth.replace("px", ""))
                    + Number(computedStyle.paddingLeft.replace("px", "")) + Number(computedStyle.paddingRight.replace("px", ""));
                var iMarginHeight = Number(computedStyle.marginTop.replace("px", "")) + Number(computedStyle.marginBottom.replace("px", ""))
                    + Number(computedStyle.borderTopWidth.replace("px", "")) + Number(computedStyle.borderBottomWidth.replace("px", ""))
                    + Number(computedStyle.paddingTop.replace("px", "")) + Number(computedStyle.paddingBottom.replace("px", ""));
                return {
                    width: element.clientWidth + iMarginWidth,
                    height: element.clientHeight + iMarginHeight
                }
            }
        }
        /**
         * Changes the stored element dimensions and mouse offset X and Y.
         *
         * @method resizeHandleDrag
         * @param  {Number} diffX The mouse movement amounts for X axe
         * @param  {Number} diffY The mouse movement amounts for Y axe
         * @param  {String} direction The resize handles that indicates wich direction is being resized.
         * @return {Boolean} True if dimensions have been processed.
         */
        resizeHandleDrag(diffX, diffY, direction,element) {
            var computedStyle , iMarginWidth,iMarginHeight, minimumHeight,minimumWidth;
            minimumHeight = 0;
            minimumWidth = 0;

            var dY = diffY, dX = diffX, processed = false;
            if(!direction){
                return false;
            }
            if (direction.indexOf('t') >= 0) {
                if (this.bbox.elmH - dY < minimumHeight) {
                    diffY = this.bbox.elmH - minimumHeight;
                    this.mouse.offset.y = dY - diffY;
                } else if (this.bbox.elmY + dY < this.minTop) {
                    diffY = this.minTop - this.bbox.elmY;
                    this.mouse.offset.y = dY - diffY;
                }
                this.bbox.elmY += diffY;
                this.bbox.elmH -= diffY;
                processed = true;
            }
            if (direction.indexOf('b') >= 0) {
                if (this.bbox.elmH + dY < minimumHeight) {
                    diffY = minimumHeight - this.bbox.elmH;
                    this.mouse.offset.y = dY - diffY;
                } else if (this.bbox.elmY + this.bbox.elmH + dY > this.maxTop) {
                    diffY = this.maxTop - this.bbox.elmY - this.bbox.elmH;
                    this.mouse.offset.y = dY - diffY;
                }
                this.bbox.elmH += diffY;
                processed = true;
            }
            if (direction.indexOf('l') >= 0) {
                if (this.bbox.elmW - dX < minimumWidth) {
                    diffX = this.bbox.elmW - minimumWidth;
                    this.mouse.offset.x = dX - diffX;
                } else if (this.bbox.elmX + dX < this.minLeft) {
                    diffX = this.minLeft - this.bbox.elmX;
                    this.mouse.offset.x = dX - diffX;
                }
                this.bbox.elmX += diffX;
                this.bbox.elmW -= diffX;
                processed = true;
            }
            if (direction.indexOf('r') >= 0) {
                if (this.bbox.elmW + dX < minimumWidth) {
                    diffX = minimumWidth - this.bbox.elmW;
                    this.mouse.offset.x = dX - diffX;
                } else if (this.bbox.elmX + this.bbox.elmW + dX > this.maxLeft) {
                    diffX = this.maxLeft - this.bbox.elmX - this.bbox.elmW;
                    this.mouse.offset.x = dX - diffX;
                }
                this.bbox.elmW += diffX;
                processed = true;
            }
            return processed;
        }
        /**
         * OnDrag event (triggered during the "drag-start" event).
         *
         * @method drag
         * @param  {Event} e The `ondragstart` event.
         */
        drag(e){
            if (e.target.dataset.direction) {
                this.resizeHandle = e.target;
            } else {
                this.resizeHandle = null;
            }
        }
        /**
         * OnDragging event (triggered when dragging an element)
         *
         * @method dragging
         * @param  {Event} dragInfo The Dragging event which contains some useful information.
         */
        dragging(dragInfo){
            var ratio = 1 / this.zoomLevel;
            var ddx = (dragInfo.detail.ddx * ratio) | 0;
            var ddy = (dragInfo.detail.ddy * ratio) | 0;
            var i;
            for ( i = 0; i < this.selectedElements.length; ++i) {
                var elementNode = this.selectedElements[i].element.$.node;
                var element = this.selectedElements[i].element;
                var overlay = this.selectedElements[i].overlay;
                if (element) {
                    if (this.resizeHandle) {
                        // Resize Element
                        var direction = this.resizeHandle.dataset.direction;
                        // Actual top, left, width and height can be a lie because does not include margins, padding.
                        // However to move object correctly you need these.
                        this.bbox.elmX = parseInt(element.style.left, 10);
                        this.bbox.elmY = parseInt(element.style.top, 10);
                        this.bbox.elmW = parseInt(element.style.width, 10);
                        this.bbox.elmH = parseInt(element.style.height,10);
                        // Work out Movement
                        this.resizeHandleDrag(ddx, ddy, direction, element);
                        // Unlock Element Size as min stops shrinking.
                        element.style.minWidth = "0px";
                        element.style.minHeight = "0px";
                        // Now Resize Element
                        this._updateElementAll(element);
                        // Check if Resize will break element.  Fix by changing minimumWidth
                        var computedStyle = this.getComputedStyle(elementNode);
                        // Get Real Size of Object
                        element.style.minWidth = elementNode.scrollWidth + Number(computedStyle.marginLeft.replace("px", ""))
                            + Number(computedStyle.marginRight.replace("px", ""))
                            - Number(computedStyle.paddingLeft.replace("px", ""))
                            - Number(computedStyle.paddingRight.replace("px", "")) + "px";
                        element.style.minHeight = elementNode.scrollHeight + Number(computedStyle.marginTop.replace("px", ""))
                            + Number(computedStyle.marginBottom.replace("px", ""))
                            - Number(computedStyle.paddingTop.replace("px", ""))
                            - Number(computedStyle.paddingBottom.replace("px", "")) + "px";
                        // Now Do Overlay
                        var position = this.position(element, elementNode);
                        var dimension = this.dimension(elementNode);
                        overlay.style.width = dimension.width + 'px';
                        overlay.style.height = dimension.height + 'px';
                        overlay.style.left = position.left + 'px';
                        overlay.style.top = position.top + 'px';
                        // Update Data Behind the Element configuration
                        this._updateGlyphAll(this.selectedElements[i].element);
                    }
                    else {
                        // Actual top, left, width and height can be a lie because does not include margins, padding.
                        // However to move object correctly you need these.
                        this.bbox.elmX = parseInt(element.style.left, 10) + ddx;
                        this.bbox.elmY = parseInt(element.style.top, 10) + ddy;
                        this._updateOverlay(element);
                        // Calculate for Overlay
                        var position = this.position(element, element.$.node);
                        var dimension = this.dimension(element.$.node);
                        overlay.style.width = dimension.width + 'px';
                        overlay.style.height = dimension.height + 'px';
                        overlay.style.left = position.left + 'px';
                        overlay.style.top = position.top + 'px';
                        this._updateGlyph(this.selectedElements[i].element);
                    }
                }
            }
            //
            // Fire Events
            //
            this.fire('edit-MovingResizeElements', this.selectedElements);
        }
        finishedDragging(dragInfo) {
            //
            // Fire Events
            //
            this.fire('edit-MoveResizeElements', this.selectedElements);
        }
        aspectRatioChanged(){
            if(this.aspectRatio === true){
                this.displayHandlers(['br']);
            }
            else {
                this.displayHandlers();
            }
        }
        _EventContextMenu(event) {
            var element = this._firstPolymerObject(event,this.baseobject);
            if (element == null) {
                // Not Found - Now Search for Any Polymer Object
                element = this._firstPolymerObject(event,"$");
            }
            var _this = this;
            if (element.classList.contains('drag-resize')) {
                // Object that can be dragged and dropped is selected.  So delete/copy/paste etc.
                console.log("Object Selected");
                if (this.selectedElements.length == 1) {
                    // Single - No Align
                    contextMenu.showMenu(this.menuData, event.target, ["add","delete","clipboard","undo"], event, function(command,node,sub,coords) {
                        if (command != null) {
                            _this.fire(command,_this.selectedElements,sub,coords);
                            console.log(command,node);
                        }
                    });
                } else {
                    // Multiple Objects
                    contextMenu.showMenu(this.menuData, event.target, ["align","delete","clipboard","undo"], event, function(command,node,sub,coords) {
                        if (command != null) {
                            _this.fire(command,_this.selectedElements,sub,coords);
                            console.log(command,node);
                        }
                    });
                }
                event.stopPropagation();
                event.preventDefault();
            } else if (event.path[0].classList.contains('Edit')) {
                // Base Page - So Can add Items or do page functions
                console.log("Base Selected");
                contextMenu.showMenu(this.menuData, event.target, ["add","undo","clipboard-paste"], event, function(command,node,sub,coords) {
                    if (command != null) {
                        coords.clientX = coords.clientX - _this.dragdropareaElement.parentElement.offsetLeft;
                        coords.clientY = coords.clientY - _this.dragdropareaElement.parentElement.offsetTop;
                        _this.fire(command,null,sub,coords);
                    }
                });
                event.stopPropagation();
                event.preventDefault();
            } else {
                // Ignore - Allow normal function of menu
                console.log("Default Context Menu");
            }
        }

        _firstPolymerObject(event, value) {
            // Internal - Find in the Event the first element that is a polymer object by searching for .$
            var i, element;
            for (i = 0; i < event.path.length; i++) {
                // Check if particular value exists.  This allows for collections of objects to be dragged.
                if (event.path[i][value] != undefined) {
                    element = event.path[i];
                    return element;
                }
            }
        }
        _checkForIgnore(event) {
            var i, element;
            for (i = 0; i < event.path.length; i++) {
                // Check if Polymer Element exit if true
                if (event.path[i].classList != null) {
                    if (event.path[i].classList.contains("drag-drop-ignore")) {
                        element = event.path[i];
                        return true;
                    }
                }
            }
            return false;
        }
        _EventMouseDown(event) {
            var element, firstElement;
            // First Element - Saved
            firstElement = event.path[0];
            // Search for specific attribute as group of objects to move.
            element = this._firstPolymerObject(event,this.baseobject);
            if (element == null) {
                // Not Found - Now Search for Any Polymer Object
                element = this._firstPolymerObject(event,"$");
            }
            // Check if first Element is drag-resize-handler - if so ignore as helper object
            if (firstElement.classList.contains('drag-resize-handlers') ||  firstElement.classList.contains('drag-resize-selected')) {
                event.stopPropagation();
                event.preventDefault();
                return;
            }
            // If searching back clicked on a none Polymer Object.  Drop selectedElements.
            if (element == undefined) {
                this.selectedElements = [];
                this.fire('edit-Cancel');
            } else {
                var filteredElements = element.classList.contains('drag-resize-handlers') ||  element.getAttribute('drag-resize') !== null;
                if(!element.classList.contains('paper-drag-drop')){
                    if(filteredElements){
                        event.stopPropagation();
                        event.preventDefault();
                        if (event.ctrlKey) {
                            // Add to list
                            this.focus(element,false);
                        } else {
                            // Replace List
                            this.focus(element,true);
                        }
                    }
                    else {
                        // Clear All Selected Elements
                        if (!this._checkForIgnore(event)) {
                            this.selectedElements = [];
                            this.fire('edit-Cancel');
                        }
                    }
                } else {
                    // Already Selected Thus....
                    //              if (event.ctrlKey) {
                    //                // Add to list
                    //                this.focus(element,false);
                    //              } else {
                    //                // Forget All and Add One
                    //                this.selectedElements = [];
                    //                this.focus(element,true);
                    //              }
                }
            }
        }
        _generateMenu(e) {
            // Simply to block Menu
            e.preventDefault();
        }
        _updateOverlay(pElement) {
            pElement.style.left = this.bbox.elmX + 'px';
            pElement.style.top = this.bbox.elmY + 'px';
        }
        _updateOverlayAll(pElement) {
            pElement.style.width = this.bbox.elmW + 'px';
            pElement.style.height = this.bbox.elmH + 'px';
            pElement.style.left = this.bbox.elmX + 'px';
            pElement.style.top = this.bbox.elmY + 'px';
        }
        _updateElementAll(pElement) {
            pElement.style.width = this.bbox.elmW + 'px';
            pElement.style.height = this.bbox.elmH + 'px';
            pElement.style.left = this.bbox.elmX + 'px';
            pElement.style.top = this.bbox.elmY + 'px';
        }
        _updateGlyph(pElement) {
            pElement.Glyph.x = this.bbox.elmX + 'px';
            pElement.Glyph.y = this.bbox.elmY + 'px';
        }
        _updateGlyphAll(pElement) {
            pElement.Glyph.x = this.bbox.elmX + 'px';
            pElement.Glyph.y = this.bbox.elmY + 'px';
            pElement.Glyph.width = this.bbox.elmW + 'px';
            pElement.Glyph.height = this.bbox.elmH + 'px';
        }
        _elementAlreadyAdded(newElement) {
            var i=0;
            var aData;
            while (aData = this.selectedElements[i++]) {
                if (aData.element === newElement) {
                    return aData;
                }
            }
            i = this.push('selectedElements',{name:"paper_drag_selected_" + this.selectedElements.length, element: newElement, overlay: null});
            return this.selectedElements[i - 1];
        }
        _parseIntDef(value) {
            return parseInt(value,10) || 0;
        }
        /**
         * Hook Paper Drag Drop into your Property Editor.
         *
         */
        SetPropertyEditor(propertyEditor) {
            if (typeof propertyEditor == 'function') {
                this.propertyEditor = propertyEditor;
            }
        }
        /**
         * `DisableEdit` Used to Switch Off Edit Paper Drag Mode
         */
        DisableEdit() {
            this.selectedElements = [];
            this.enable = false;
        }
        /**
         * `EnableEdit` Used to Switch On Edit Paper Drag Mode
         */
        EnableEdit() {
            this.enable = true;
        }
        /**
         * Fire - To replace Polymer 1.x version that disappeared!
         * @param name of event
         * @param detail
         */
        fire_old(name, details) {
            document.dispatchEvent(new CustomEvent(name, {detail: details}));
        }
        fire(name, details, sub, coords) {
            document.dispatchEvent(new CustomEvent(name, {detail: {detail: details, subcommand: sub, coords: coords}}));
        }
        //
        //
        //
        getComputedStyle(element) {
            if(element) {
                // Get Shadow CSS of Host to get Internal Margins.
                if (element.root == null) {
                    return window.getComputedStyle(element);
                } else {
                    return window.getComputedStyle(element.root.host);
                }
            }
        }
        //
        // If Elements are altered external (not dragged) then update so that overlays move correctly.
        //
        _EventRefreshOverlays() {
            var i;
            for (i = 0; i < this.selectedElements.length; ++i) {
                var elementNode = this.selectedElements[i].element.$.node;
                var element = this.selectedElements[i].element;
                var overlay = this.selectedElements[i].overlay;
                if (element) {
                    var position = this.position(element, elementNode);
                    // Node can be bigger than the holding element.  Thus use node for the actual
                    // size, with the element for position.
                    var dimension = this.dimension(elementNode);
                    overlay.style.width = dimension.width + 'px';
                    overlay.style.height = dimension.height + 'px';
                    overlay.style.left = position.left + 'px';
                    overlay.style.top = position.top + 'px';
                }
            }
        }
        //
        // Refocus Event.
        //
        _EventRefocus(event) {
            var _this = this;
            // Delete All Current Selected Items
            this.blur(true);
            if (event.detail != null) {
                Array.prototype.forEach.call(event.detail.detail , function(el, i){
                    _this.focus(el,false);
                });
            }
            this._EventRefreshOverlays();
        }
    }
    customElements.define(PaperDragDrop.is, PaperDragDrop);
</script>

