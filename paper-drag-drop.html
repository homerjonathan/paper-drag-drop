<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-iconset-svg/iron-iconset-svg.html">
<!--
Paper Drag Drop -
Based On Component By (But extensively changed now):
  Copyright (c) 2014 Wassim Chegham. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
Icons From:
  Many Great Icons are provided by the Google Polymer Team - Just embedded for quick download. Under BSD style license
  See - https://github.com/PolymerElements/iron-icons/blob/master/iron-icons.html
  Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
-->

<!--
Element that enables any DOM element to be draggable and resizable.
##### Example
    <drag-resize></drag-resize>
@element paper-drag-drop
@blurb Element that enables any DOM element to be draggable and resizable.
@status beta
@homepage https://github.io/manekinekko/drag-resize
@demo demo/index.html
-->
<dom-module id="paper-drag-drop">
  <template>
    <style>
      /*
        Resize of Elements - Overlay
       */
      .drag-resize-selected {
        border: 1px dotted rgb(0, 150, 253);
        cursor: move;
        display: block;
        width: 100%;
        height: 100%;
        position: absolute;
        z-index: 999;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
      }
      .drag-resize-handlers {
        position: absolute;
        width: 8px;
        height: 8px;
        font-size: 1px;
        background: rgb(0, 150, 253);
        -webkit-transition: all 0.1s linear;
        transition: all 0.1s linear;
        opacity: 1;
        border-radius: 5px;
        border: 0px solid black;
      }
      :host(.drag-resize-selected) .drag-resize-handlers {
        opacity: 1;
      }
      .drag-resize-handlers:hover {
        transform: scale(1.6); /*chrome*/
        -webkit-transform: scale(1.6); /*nodewebkit*/
        border: 1px solid black;
      }
      /*
       Individual corner classes - required for resize support.
      */
      .drag-resize-handlers[data-direction="tl"] {
        top: -5px;
        left: -5px;
        cursor: nw-resize;
      }
      .drag-resize-handlers[data-direction="tm"] {
        top: -5px;
        left: 50%;
        margin-left: -5px;
        cursor: n-resize;
      }
      .drag-resize-handlers[data-direction="tr"] {
        top: -5px;
        right: -5px;
        cursor: ne-resize;
      }
      .drag-resize-handlers[data-direction="ml"] {
        top: 50%;
        margin-top: -5px;
        left: -5px;
        cursor: w-resize;
      }
      .drag-resize-handlers[data-direction="mr"] {
        top: 50%;
        margin-top: -5px;
        right: -5px;
        cursor: e-resize;
      }
      .drag-resize-handlers[data-direction="bl"] {
        bottom: -5px;
        left: -5px;
        cursor: sw-resize;
      }
      .drag-resize-handlers[data-direction="bm"] {
        bottom: -5px;
        left: 50%;
        margin-left: -5px;
        cursor: s-resize;
      }
      .drag-resize-handlers[data-direction="br"] {
        bottom: -5px;
        right: -5px;
        cursor: se-resize;
      }
    </style>
    <iron-iconset-svg name="paperdragdrop" size="24">
      <svg><defs>
        <g id="content-copy"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></g>
        <g id="content-cut"><path d="M9.64 7.64c.23-.5.36-1.05.36-1.64 0-2.21-1.79-4-4-4S2 3.79 2 6s1.79 4 4 4c.59 0 1.14-.13 1.64-.36L10 12l-2.36 2.36C7.14 14.13 6.59 14 6 14c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4c0-.59-.13-1.14-.36-1.64L12 14l7 7h3v-1L9.64 7.64zM6 8c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm0 12c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm6-7.5c-.28 0-.5-.22-.5-.5s.22-.5.5-.5.5.22.5.5-.22.5-.5.5zM19 3l-6 6 2 2 7-7V3z"/></g>
        <g id="content-paste"><path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"/></g>
        <!--<g id="vertical-align-bottom"><path d="M16 13h-3V3h-2v10H8l4 4 4-4zM4 19v2h16v-2H4z"/></g>-->
        <g id="vertical-align-bottom" viewBox="0 0 16 16">
          <line fill="none" stroke="#000000" stroke-width="1.0568" stroke-miterlimit="10" x1="15.2" y1="14.6" x2="0.8" y2="14.6"/>
          <rect x="8.9" y="4.7" width="4.8" height="8.1"/>
          <rect x="2.3" y="1.4" fill="none" stroke="#000000" stroke-width="0.7284" stroke-miterlimit="10" width="5" height="11.1"/>
        </g>
        <g id="align-center" viewBox="0 0 16 16">
          <line fill="none" stroke="#000000" stroke-width="1.0568" stroke-miterlimit="10" x1="15.2" y1="8" x2="0.8" y2="8"/>
          <rect x="8.9" y="4" width="4.8" height="8.1"/>
          <rect x="2.3" y="2.5" fill="#FFFFFF" stroke="#000000" stroke-width="0.7284" stroke-miterlimit="10" width="5" height="11.1"/>
        </g>
        <g id="vertical-align-center" viewBox="0 0 16 16">
          <line fill="none" stroke="#000000" stroke-width="1.0568" stroke-miterlimit="10" x1="8" y1="15.2" x2="8" y2="0.8"/>
          <rect x="4" y="8.9" width="8.1" height="4.8"/>
          <rect x="2.5" y="2.3" fill="#FFFFFF" stroke="#000000" stroke-width="0.7284" stroke-miterlimit="10" width="11.1" height="5"/>
        </g>
        <g id="vertical-align-top" viewBox="0 0 16 16">
          <line fill="none" stroke="#000000" stroke-width="1.0568" stroke-miterlimit="10" x1="15.2" y1="1.4" x2="0.8" y2="1.4"/>
          <rect x="8.9" y="3.2" width="4.8" height="8.1"/>
          <rect x="2.3" y="3.5" fill="none" stroke="#000000" stroke-width="0.7284" stroke-miterlimit="10" width="5" height="11.1"/>
        </g>
        <g id="align-left" viewBox="0 0 16 16">
          <line fill="none" stroke="#000000" stroke-width="1.0568" stroke-miterlimit="10" x1="2.1" y1="1" x2="2.1" y2="15.3"/>
          <rect x="3.9" y="2.4" width="8.1" height="4.8"/>
          <rect x="4.3" y="8.8" fill="none" stroke="#000000" stroke-width="0.7284" stroke-miterlimit="10" width="11.1" height="5"/>
        </g>
        <g id="align-right" viewBox="0 0 16 16">
          <line fill="none" stroke="#000000" stroke-width="1.0568" stroke-miterlimit="10" x1="14.3" y1="1" x2="14.3" y2="15.3"/>
          <rect x="4.4" y="2.4" width="8.1" height="4.8"/>
          <rect x="1.1" y="8.8" fill="none" stroke="#000000" stroke-width="0.7284" stroke-miterlimit="10" width="11.1" height="5"/>
        </g>
        <g id="grow-height" viewBox="0 0 16 16">
          <rect x="6.3" y="4" width="3.2" height="8.1"/>
          <rect x="10.9" y="2.5" fill="#FFFFFF" stroke="#000000" stroke-width="0.6021" stroke-miterlimit="10" width="3.4" height="11.1"/>
          <path fill-rule="evenodd" clip-rule="evenodd" d="M3.6,13.6c-0.2,0.2-0.4,0.2-0.6,0l-1.2-1.2c-0.2-0.2-0.2-0.4,0-0.6
	c0.2-0.2,0.4-0.2,0.6,0l0.5,0.5l0-3.1c0-0.1,0-0.2,0.1-0.3c0.2-0.2,0.4-0.2,0.6,0C3.7,9,3.7,9.1,3.7,9.2v3.1l0.5-0.5
	c0.2-0.2,0.4-0.2,0.6,0C5,12,5,12.2,4.8,12.4l0,0L3.6,13.6z"/>
          <path fill-rule="evenodd" clip-rule="evenodd" d="M3.7,6.8c0,0.1,0,0.2-0.1,0.3C3.4,7.2,3.2,7.2,3,7.1C2.9,7,2.9,6.9,2.9,6.8V3.7
	L2.4,4.2c-0.2,0.2-0.4,0.2-0.6,0C1.6,4,1.6,3.8,1.8,3.6L3,2.4c0.2-0.2,0.4-0.2,0.6,0l1.2,1.2C5,3.8,5,4,4.8,4.2
	c-0.2,0.2-0.4,0.2-0.6,0L3.7,3.7V6.8"/>
        </g>
        <g id="shrink-width" viewBox="0 0 16 16">
          <rect x="3.9" y="11.2" fill="#FFFFFF" stroke="#000000" stroke-width="0.6021" stroke-miterlimit="10" width="8.1" height="3.2"/>
          <rect x="2.4" y="6.3" width="11.1" height="3.4"/>
          <path d="M13.3,3.8h-3.1l0.5,0.5c0.2,0.2,0.2,0.4,0,0.6c-0.2,0.2-0.4,0.2-0.6,0L8.9,3.6C8.7,3.5,8.7,3.2,8.9,3l1.2-1.2
	c0.2-0.2,0.4-0.2,0.6,0c0.2,0.2,0.2,0.4,0,0.6l-0.5,0.5h3.1c0.1,0,0.2,0,0.3,0.1c0.2,0.2,0.2,0.4,0,0.6C13.5,3.7,13.4,3.8,13.3,3.8
	 M5.2,4.9C5,4.7,5,4.4,5.2,4.3l0.5-0.5H2.6c-0.1,0-0.2,0-0.3-0.1C2.1,3.5,2.1,3.2,2.3,3c0.1-0.1,0.2-0.1,0.3-0.1h3.1L5.2,2.4
	C5,2.2,5,2,5.2,1.8c0.2-0.2,0.4-0.2,0.6,0L7,3c0.2,0.2,0.2,0.4,0,0.6L5.8,4.9C5.6,5,5.4,5,5.2,4.9"/>
        </g>

        <g id="shrink-height" viewBox="0 0 16 16">
          <rect x="11.1" y="4" fill="#FFFFFF" stroke="#000000" stroke-width="0.6021" stroke-miterlimit="10" width="3.2" height="8.1"/>
          <rect x="6.3" y="2.5" width="3.4" height="11.1"/>
          <path fill-rule="evenodd" clip-rule="evenodd" d="M3,8.9c0.2-0.2,0.4-0.2,0.6,0l1.2,1.2c0.2,0.2,0.2,0.4,0,0.6
	c-0.2,0.2-0.4,0.2-0.6,0l-0.5-0.5l0,3.1c0,0.1,0,0.2-0.1,0.3c-0.2,0.2-0.4,0.2-0.6,0c-0.1-0.1-0.1-0.2-0.1-0.3l0-3.1l-0.5,0.5
	c-0.2,0.2-0.4,0.2-0.6,0c-0.2-0.2-0.2-0.4,0-0.6l0,0L3,8.9z"/>
          <path fill-rule="evenodd" clip-rule="evenodd" d="M2.9,2.7c0-0.1,0-0.2,0.1-0.3c0.2-0.2,0.4-0.2,0.6,0c0.1,0.1,0.1,0.2,0.1,0.3v3.1
	l0.5-0.5c0.2-0.2,0.4-0.2,0.6,0C5,5.4,5,5.7,4.8,5.8L3.6,7.1C3.4,7.2,3.2,7.2,3,7.1L1.8,5.8c-0.2-0.2-0.2-0.4,0-0.6
	c0.2-0.2,0.4-0.2,0.6,0l0.5,0.5V2.7"/>
        </g>

        <g id="grow-width" viewBox="0 0 16 16">
          <rect x="3.9" y="6.3" width="8.1" height="3.2"/>
          <rect x="2.4" y="10.9" fill="#FFFFFF" stroke="#000000" stroke-width="0.6021" stroke-miterlimit="10" width="11.1" height="3.4"/>
          <path fill-rule="evenodd" clip-rule="evenodd" d="M12.4,4.9L12.4,4.9c-0.2,0.2-0.4,0.2-0.6,0c-0.2-0.2-0.2-0.4,0-0.6l0.5-0.5H9.2
	c-0.1,0-0.2,0-0.3-0.1C8.7,3.5,8.7,3.2,8.9,3C9,2.9,9.1,2.9,9.2,2.9l3.1,0l-0.5-0.5c-0.2-0.2-0.2-0.4,0-0.6c0.2-0.2,0.4-0.2,0.6,0
	L13.6,3c0.2,0.2,0.2,0.4,0,0.6L12.4,4.9z M6.7,3.8H3.7l0.5,0.5c0.2,0.2,0.2,0.4,0,0.6C4,5,3.7,5,3.6,4.9L2.3,3.6
	C2.1,3.5,2.1,3.2,2.3,3l1.2-1.2c0.2-0.2,0.4-0.2,0.6,0c0.2,0.2,0.2,0.4,0,0.6L3.7,2.9h3.1C6.8,2.9,7,2.9,7,3c0.2,0.2,0.2,0.4,0,0.6
	C7,3.7,6.8,3.8,6.7,3.8"/>
        </g>


        <g id="undo"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/></g>
        <g id="delete"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></g>
      </defs></svg>
    </iron-iconset-svg>
    <div id="resizable_handlers">
      <template id="selectedelements" is="dom-repeat" items="{{selectedElements}}">
        <div id="{{item.name}}" class="drag-resize-selected" on-track="_eventOnTrack" >
          <div class="drag-resize-handlers" data-direction="tl"></div>
          <div class="drag-resize-handlers" data-direction="tm"></div>
          <div class="drag-resize-handlers" data-direction="tr"></div>
          <div class="drag-resize-handlers" data-direction="mr"></div>
          <div class="drag-resize-handlers" data-direction="ml"></div>
          <div class="drag-resize-handlers" data-direction="bl"></div>
          <div class="drag-resize-handlers" data-direction="bm"></div>
          <div class="drag-resize-handlers" data-direction="br"></div>
        </div>
      </template>
    </div>
  </template>
</dom-module>
<!--
-->
<script>
    class PaperDragDrop extends Polymer.GestureEventListeners(Polymer.Element) {
        static get is() { return 'paper-drag-drop'; }
        static get properties() { return {
            selectedElements: {
                type: Array,
                notify: true,
                value: []
            },
            menuAddObjects: {
                type: Array,
                notify: true,
                observer: "_doMenu"
            },
            aspectRatio: {
                /**
                 * `aspectRatio` is a property that preserves the aspectRatio.
                 *
                 * @property aspectRatio
                 * @type bool
                 * @default false
                 */
                type: Boolean,
                value: false
            },
            /**
             * `minWidth` is the minimum pixel width of the element.
             *
             * @property minWidth
             * @type number
             * @default 30
             */
            minWidth: {
                type: Number,
                value: 8
            },
            /**
             * `minHeight` is the minimum pixel height of the element.
             *
             * @property minHeight
             * @type number
             * @default 30
             */
            minHeight: {
                type: Number,
                value: 8
            },
            class: {
                type: String,
                value: "drag-resize",
                reflectToAttribute: true
            },
            dragdroparea: {
                type: String,
                value: "paper-drag-drop-zone"
            },
            baseobject: {
                type: String,
                value: "$"
            }
        }
        }
        constructor() {
            super();
            this.selectedElement = null;
            this.resizeHandle = null;
            this.enable = true;
            this.menuAddObjects = [];
            this._doMenu();
            this._Bind_EventMouseDown = this._EventMouseDown.bind(this);
            this._Bind_EventContextMenu = this._EventContextMenu.bind(this);
            this._Bind_EventRefreshOverlays = this._EventRefreshOverlays.bind(this);
            this._Bind_EventRefocus = this._EventRefocus.bind(this);
            this._Bind_EventKeys = this._EventKeys.bind(this);
        }
        /**
         *
         *  Menu Data - Most is fixed.  However to add your own components follow this format and enter it here this.menuAddObjects
         *
         **/
        _doMenu() {
            this.menuData = [
                {
                    type: "align", description: "Align", command: "",
                    submenu: [
                        {type: "align", description: "Left", command: "edit-Align", subcommand:"Left",icon: "paperdragdrop:align-left"},
                        {type: "align", description: "Right", command: "edit-Align",subcommand:"Right",icon: "paperdragdrop:align-right"},
                        {type: "align", description: "Top", command: "edit-Align",subcommand:"Top",icon: "paperdragdrop:vertical-align-top"},
                        {type: "align", description: "Bottom", command: "edit-Align",subcommand:"Bottom",icon: "paperdragdrop:vertical-align-bottom"},
                        {type: "align", description: "Vertical Center", command: "edit-Align",subcommand:"Vertical",icon: "paperdragdrop:vertical-align-center"},
                        {type: "align", description: "Horizontal Center", command: "edit-Align",subcommand:"Horizontal",icon: "paperdragdrop:align-center"},
                        {type: "align", description: "Horizontal Evenly", command: "edit-Align",subcommand:"HorizontalEvenly",icon: "paperdragdrop:align-vertical-evenly"},
                        {type: "align", description: "Vertical Evenly", command: "edit-Align",subcommand:"VerticalEvenly",icon: "paperdragdrop:align-evenly"}
                    ]
                },
                {
                    type: "align", description: "Resize", command: "", icon:"arrow-drop-down",
                    submenu: [
                        {type: "align", description: "Grow to Largest Width", command: "edit-Resize", subcommand:"GrowWidth",icon:"paperdragdrop:grow-width"},
                        {type: "align", description: "Shrink to Smallest Width", command: "edit-Resize", subcommand:"ShrinkWidth",icon:"paperdragdrop:shrink-width"},
                        {type: "align", description: "Grow to Largest Height", command: "edit-Resize", subcommand:"GrowHeight",icon:"paperdragdrop:grow-height"},
                        {type: "align", description: "Shrink to Smallest Height", command: "edit-Resize", subcommand:"ShrinkHeight",icon:"paperdragdrop:shrink-height"}
                    ]
                },
                {type: "add", description: "Add", command: "",submenu: this.menuAddObjects},
                {type: "add", description: "-", command: ""},
                {type: "clipboard", description: "Copy", command: "edit-Clipboard", subcommand:"Copy", icon: "paperdragdrop:content-copy"},
                {type: "clipboard", description: "Cut", command: "edit-Clipboard", subcommand:"Cut",icon: "paperdragdrop:content-cut"},
                {type: "clipboard-paste", description: "Paste", command: "edit-Clipboard", subcommand:"Paste", icon: "paperdragdrop:content-paste"},
                {type: "undo", description: "Undo", command: "edit-UndoStep",icon: "paperdragdrop:undo"},
                {type: "delete", description: "-", command: ""},
                {type: "delete", description: "Delete", command: "edit-Delete",icon: "paperdragdrop:delete"}
            ];
        }
        connectedCallback() {
            super.connectedCallback();
            this._addListeners();
            // Find out Drag Drop Area so we can work out where it was clicked
            if (this.dragdropareaElement == null) {
                this.dragdropareaElement = app.Poly.page.shadowRoot.querySelector('#' + this.dragdroparea);
            }
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            this._removeListeners();
        }
        _addListeners() {
            document.addEventListener('mousedown', this._Bind_EventMouseDown);
            document.addEventListener('contextmenu', this._Bind_EventContextMenu);
            document.addEventListener('edit-RefreshOverlays', this._Bind_EventRefreshOverlays);
            document.addEventListener('edit-Refocus', this._Bind_EventRefocus);
            document.addEventListener('keydown', this._Bind_EventKeys);
        }
        _removeListeners() {
            document.removeEventListener('mousedown', this._Bind_EventMouseDown);
            document.removeEventListener('contextmenu', this._Bind_EventContextMenu);
            document.removeEventListener('edit-RefreshOverlays', this._Bind_EventRefreshOverlays);
            document.removeEventListener('edit-Refocus', this._Bind_EventRefocus);
            document.removeEventListener('keydown', this._Bind_EventKeys);
        }
        /**
         * This method is used to show all or a subset of the resize handlers.
         *
         * @method displayHandlers
         * @param {Array} filters An array of the handlers to show. If the array is empty or not provided, then all the handlers are shown.
         */
        displayHandlers(filters){
            var handlersContainer = this.$.resizable_handlers;
            var handlers = [].slice.call(handlersContainer.querySelectorAll('[data-direction]'));
            if(filters && filters.length>0){
                // first, hide all
                handlers.forEach(function(handler, index, self){
                    handler.style.visibility = 'hidden';
                });
                // show filtered only
                filters.map(function(filter, index, self){
                    var dom = handlersContainer.querySelector('[data-direction="'+filter+'"]');
                    if(dom){
                        dom.style.visibility = 'visible';
                    }
                    return dom;
                });
            }
            else {
                // show all
                handlers.forEach(function(handler, index, self){
                    handler.style.visibility = 'visible';
                });
            }
        }
        /**
         * The `ontap` handler.
         *
         * @method ontap
         * @param  {Event} event The `ontap` event.
         */
        ontap(event){
            event.stopPropagation();
            event.preventDefault();
        }
        //
        // Internal On Track Event
        //
        _eventOnTrack(e) {
            switch(e.detail.state) {
                case 'start':
                    this.drag(e);
                    break;
                case 'track':
                    this.dragging(e);
                    break;
                case 'end':
                    this.finishedDragging(e);
                    break;
            }
            e.stopPropagation();
            e.preventDefault();
        }
        /**
         * Focus add Element to list of Elements selected
         *
         * @method focus
         * @param  {newElement} newElement The element to be selected.
         * @param  {replace} replace Boolean to indicate if other elements selected are to be removed and replaced with this one.
         */
        focus(newElement, replace){
            // Should only be called when new item selected.  Otherwise something has gone wrong.
            if (replace === true) {
                // Clear Out Result
                this.selectedElements = [];
            }
            if ( this.enable && newElement && !newElement.classList.contains('drag-resize-selected') ) {
                // Add With Index Name - Use Polymer so it can see the request
                var overlayData = this._elementAlreadyAdded(newElement);
                // Force immediate render.  No performance issues as only human speed of clicking
                this.$.selectedelements.render();
                // Not the most elegant but...grab overlay
                var overlay = this.shadowRoot.querySelector('#' + overlayData.name);
                // Hook Overlay into selected elements
                overlayData.overlay = overlay;
                // Now Use as Normal
                var element = overlayData.element;
                var elementNode = newElement.$.node;
                var data = { left: parseInt(element.style.left, 10),
                    top: parseInt(element.style.top, 10),
                    width: parseInt(element.style.width, 10),
                    height: parseInt(element.style.top, 10)};
                // Calculate the real size of the node
                var cr = this.getComputedStyleResults(elementNode);
                // Update Overlay
                this._updateStylePositionSize(overlay,cr.offsetLeft + data.left, cr.offsetTop + data.top,cr.styleMinWidth,cr.styleMinHeight);
                // Update Data - Main value here is the Min Height and Width
                this._updateGlyphPositionSize(element,data.left, data.top, cr.minWidth,cr.minHeight);
                //
                // Fire Edit Element
                //
                this.fire('edit-Element', this.selectedElements,"",this.coordsClicked);
            }
        }
        /**
         * Blur (deselect) the active element.
         *
         * @method blur
         */
        blur(){
            this.fire('edit-Cancel', null);
            this.resizeHandle = null;
        }
        /**
         * Changes the stored element dimensions and mouse offset X and Y.
         *
         * @method resizeHandleDrag
         * @param  {Number} diffX The mouse movement amounts for X axe
         * @param  {Number} diffY The mouse movement amounts for Y axe
         * @param  {String} direction The resize handles that indicates which direction is being re-sized.
         * @element {Object} Object being moved
         * @return {Boolean} True if dimensions have been processed.
         */
        resizeHandleDrag(diffX, diffY, direction, element) {
            var results = {
                top: parseInt(element.style.top, 10),
                left: parseInt(element.style.left, 10),
                width: parseInt(element.style.width, 10),
                height: parseInt(element.style.height,10)
            };
            if(!direction){
                return false;
            }
            if (direction.indexOf('t') >= 0) {
                results.top += diffY;
                results.height -= diffY;
            }
            if (direction.indexOf('b') >= 0) {
                results.height += diffY;
            }
            if (direction.indexOf('l') >= 0) {
                results.left += diffX;
                results.width -= diffX;
            }
            if (direction.indexOf('r') >= 0) {
                results.width += diffX;
            }
            return results;
        }
        /**
         * OnDrag event (triggered during the "drag-start" event).
         *
         * @method drag
         * @param  {Event} e The `ondragstart` event.
         */
        drag(e){
            // Are we dragging small resize DIV or Main Overlay DIV
            if (e.target.dataset.direction) {
                // Dragging Small Resize DIV
                this.resizeHandle = e.target;
            } else {
                // Dragging Main Overlay DIV
                this.resizeHandle = null;
            }
        }
        /**
         * OnDragging event (triggered when dragging an element)
         *
         * @method dragging
         * @param  {Event} dragInfo The Dragging event which contains some useful information.
         */
        dragging(dragInfo){
            var ddx = dragInfo.detail.ddx | 0;
            var ddy = dragInfo.detail.ddy | 0;
            for ( var i = 0; i < this.selectedElements.length; ++i) {
                // This is actual side of the element
                var elementNode = this.selectedElements[i].element.$.node;
                // This is the Polymer Object being moved
                var element = this.selectedElements[i].element;
                // This is the overlay border that allows the shape to resized
                var overlay = this.selectedElements[i].overlay;
                // Check that we are accessing a Element
                if (element) {
                    if (this.resizeHandle) {
                        //
                        // Resize Element
                        //
                        var direction = this.resizeHandle.dataset.direction;
                        var data = this.resizeHandleDrag(ddx, ddy, direction, element);
                        // Unlock Element Size as min stops shrinking.
                        this._updateStyleMinSize(element, this.minWidth, this.minHeight);
                        // Move Actual Element
                        this._updateStylePositionSize(element,data.left, data.top, data.width, data.height);
                        // Calculate if allowed to Shrink
                        var cr = this.getComputedStyleResults(elementNode);
                        // Fix the Size
                        this._updateStyleMinSize(element,cr.styleExcludeWidth,cr.styleExcludeHeight);
                        // Resize the Overlay to fixed size
                        this._updateStylePositionSize(overlay,cr.offsetLeft + data.left, cr.offsetTop + data.top,cr.styleMinWidth,cr.styleMinHeight);
                        // Update Data Behind the Element configuration - Locking Min Width and Min Height
                        this._updateGlyphPositionSize(element,data.left, data.top, cr.minWidth,cr.minHeight);
                    } else {
                        //
                        // Moving Object
                        //
                        // Apply Mouse movements in ddx and ddy to element
                        var data = { left: parseInt(element.style.left, 10) + ddx,
                            top: parseInt(element.style.top, 10) + ddy};
                        this._updateStylePositionOnly(element,data.left,data.top);
                        // Calculate for Overlay
                        // Actual top, left, width and height can be a lie because does not include margins, padding.
                        // Calculate if allowed to Shrink
                        var cr = this.getComputedStyleResults(elementNode);
                        // Resize the Overlay to fixed size
                        this._updateStylePositionSize(overlay,cr.offsetLeft + data.left, cr.offsetTop + data.top,cr.styleMinWidth,cr.styleMinHeight);
                        // Update Data Behind the Element configuration - Locking Min Width and Min Height
                        this._updateGlyphPositionSize(element,data.left, data.top, cr.minWidth,cr.minHeight);
                    }
                }
            }
            //
            // Fire Events
            //
            this.fire('edit-MovingResizeElements', this.selectedElements);
        }

        finishedDragging() {
            //
            // Fire Events
            //
            this.fire('edit-MoveResizeElements', this.selectedElements);
        }

        aspectRatioChanged(){
            if(this.aspectRatio === true){
                this.displayHandlers(['br']);
            }
            else {
                this.displayHandlers();
            }
        }
        _EventContextMenu(event) {
            var element = this._firstPolymerObject(event,this.baseobject);
            if (element == null) {
                // Not Found - Now Search for Any Polymer Object
                element = this._firstPolymerObject(event,"$");
            }
            var _this = this;
            if (element.classList.contains('drag-resize')) {
                // Object that can be dragged and dropped is selected.  So delete/copy/paste etc.
                console.log("Object Selected");
                if (this.selectedElements.length == 1) {
                    // Single - No Align
                    contextMenu.showMenu(this.menuData, event.target, ["add","delete","clipboard","undo"], event, function(command,node,sub,coords) {
                        if (command != null) {
                            _this.fire(command,_this.selectedElements,sub,coords);
                            console.log(command,node);
                        }
                    });
                } else {
                    // Multiple Objects
                    contextMenu.showMenu(this.menuData, event.target, ["align","delete","clipboard","undo"], event, function(command,node,sub,coords) {
                        if (command != null) {
                            _this.fire(command,_this.selectedElements,sub,coords);
                            console.log(command,node);
                        }
                    });
                }
                event.stopPropagation();
                event.preventDefault();
            } else if (event.path[0].classList.contains('Edit')) {
                // Base Page - So Can add Items or do page functions
                console.log("Base Selected");
                contextMenu.showMenu(this.menuData, event.target, ["add","undo","clipboard-paste"], event, function(command,node,sub,coords) {
                    if (command != null) {
                        coords.clientX = coords.clientX - _this.dragdropareaElement.parentElement.offsetLeft;
                        coords.clientY = coords.clientY - _this.dragdropareaElement.parentElement.offsetTop;
                        _this.fire(command,null,sub,coords);
                    }
                });
                event.stopPropagation();
                event.preventDefault();
            } else {
                // Ignore - Allow normal function of menu
                console.log("Default Context Menu");
            }
        }
        _firstPolymerObject(event, value) {
            // Internal - Find in the Event the first element that is a polymer object by searching for .$
            var i, element;
            for (i = 0; i < event.path.length; i++) {
                // Check if particular value exists.  This allows for collections of objects to be dragged.
                if (event.path[i][value] != undefined) {
                    element = event.path[i];
                    return element;
                }
            }
        }
        //
        // Add to Class of Object "drag-drop-ignore" if found assumes not to clear elements selected
        //
        _checkForIgnore(event) {
            var i, element;
            for (i = 0; i < event.path.length; i++) {
                // Check if Polymer Element exit if true
                if (event.path[i].classList != null) {
                    if (event.path[i].classList.contains("drag-drop-ignore")) {
                        element = event.path[i];
                        return true;
                    }
                }
            }
            return false;
        }

        _EventMouseDown(event) {
            var element, firstElement;
            // First Element - Saved
            firstElement = event.path[0];
            // Search for specific attribute as group of objects to move.
            element = this._firstPolymerObject(event,this.baseobject);
            if (element == null) {
                // Not Found - Now Search for Any Polymer Object
                element = this._firstPolymerObject(event,"$");
            }
            // Check if first Element is drag-resize-handler - if so ignore as helper object
            if (firstElement.classList.contains('drag-resize-handlers') ||  firstElement.classList.contains('drag-resize-selected')) {
                event.stopPropagation();
                event.preventDefault();
                return;
            }
            // If searching back clicked on a none Polymer Object.  Drop selectedElements.
            if (element == undefined) {
                this.selectedElements = [];
                this.fire('edit-Cancel');
            } else {
                var filteredElements = element.classList.contains('drag-resize-handlers') ||  element.getAttribute('drag-resize') !== null;
                if(!element.classList.contains('paper-drag-drop')){
                    if(filteredElements){
                        event.stopPropagation();
                        event.preventDefault();
                        // Store Mouse Click - Focus Needs this value
                        this._positionClicked(event);
                        // Check if control key is pressed
                        if (event.ctrlKey) {
                            // Add to list
                            this.focus(element,false);
                        } else {
                            // Replace List
                            this.focus(element,true);
                        }
                    }
                    else {
                        // Clear All Selected Elements
                        if (!this._checkForIgnore(event)) {
                            this.selectedElements = [];
                            this.fire('edit-Cancel');
                        } else {
                            // Don't Block
                            return;
                        }
                    }
                } else {
                    // Already Selected Thus....
                    //              if (event.ctrlKey) {
                    //                // Add to list
                    //                this.focus(element,false);
                    //              } else {
                    //                // Forget All and Add One
                    //                this.selectedElements = [];
                    //                this.focus(element,true);
                    //              }
                    console.log("Already Clicked!");
                }
            }
            event.stopPropagation();
            event.preventDefault();
        }
        _generateMenu(e) {
            // Simply to block Menu
            e.preventDefault();
        }

        _updateStylePositionOnly(element,left,top) {
            element.style.left = left + 'px';
            element.style.top = top + 'px';
        }
        _updateStylePositionSize(element,left,top,width,height) {
            element.style.left = left + 'px';
            element.style.top = top + 'px';
            element.style.width = width + 'px';
            element.style.height = height + 'px';
        }
        _updateStyleMinSize(element,width,height) {
            element.style.minWidth = width + 'px';
            element.style.minHeight = height + 'px';
        }
        _updateGlyphPositionOnly(element,left,top) {
            element.Glyph.x = left + 'px';
            element.Glyph.y = top + 'px';
        }
        _updateGlyphPositionSize(element,left,top,width,height) {
            element.Glyph.x = left + 'px';
            element.Glyph.y = top + 'px';
            element.Glyph.width = width + 'px';
            element.Glyph.height = height + 'px';
        }

        _elementAlreadyAdded(newElement) {
            var i=0;
            var aData;
            while (aData = this.selectedElements[i++]) {
                if (aData.element === newElement) {
                    return aData;
                }
            }
            i = this.push('selectedElements',{name:"paper_drag_selected_" + this.selectedElements.length, element: newElement, overlay: null});
            return this.selectedElements[i - 1];
        }
        _parseIntDef(value) {
            return parseInt(value,10) || 0;
        }
        /**
         * Hook Paper Drag Drop into your Property Editor.
         *
         */
        SetPropertyEditor(propertyEditor) {
            if (typeof propertyEditor == 'function') {
                this.propertyEditor = propertyEditor;
            }
        }
        /**
         * `DisableEdit` Used to Switch Off Edit Paper Drag Mode
         */
        DisableEdit() {
            this.selectedElements = [];
            this.enable = false;
        }
        /**
         * `EnableEdit` Used to Switch On Edit Paper Drag Mode
         */
        EnableEdit() {
            this.enable = true;
        }
        /**
         * Fire - To replace Polymer 1.x version that disappeared!
         * @param name of event
         * @param detail Array of objects event is for
         * @param sub Subcommand.  Makes it easy to merge commands into one event
         * @param coords Where the mouse was clicked.  Useful for Add to page and not allow tool window to overlay
         */
        fire(name, details, sub, coords) {
            document.dispatchEvent(new CustomEvent(name, {detail: {detail: details, subcommand: sub, coords: coords}}));
        }
        //
        // Get Computed Style - From Window Or Shadow Root
        //
        getComputedStyle(element) {
            if(element) {
                // Get Shadow CSS of Host to get Internal Margins.
                if (element.root == null) {
                    return window.getComputedStyle(element);
                } else {
                    return window.getComputedStyle(element.root.host);
                }
            }
        }
        //
        // Work out Min Size, Location and Size from Computed Values
        //
        getComputedStyleResults(element) {
            var computedStyle = this.getComputedStyle(element);
            var results = {};
            //
            // Minimum Width, Height - Most HTML elements will only shrink so far.  So this returns that minimum
            //
            results.minWidth = element.scrollWidth;
            results.minHeight = element.scrollHeight;
            // Calculate Padding Margins and Widths of Borders that is the Real size of Object!
            var overlapWidth = Number(computedStyle.marginLeft.replace("px", ""))
                + Number(computedStyle.marginRight.replace("px", ""))
                + Number(computedStyle.paddingLeft.replace("px", ""))
                + Number(computedStyle.paddingRight.replace("px", ""))
                + Number(computedStyle.borderLeftWidth.replace("px", ""))
                + Number(computedStyle.borderRightWidth.replace("px", ""));
            var overlapHeight = Number(computedStyle.marginTop.replace("px", ""))
                + Number(computedStyle.marginBottom.replace("px", ""))
                + Number(computedStyle.paddingTop.replace("px", ""))
                + Number(computedStyle.paddingBottom.replace("px", ""))
                + Number(computedStyle.borderTopWidth.replace("px", ""))
                + Number(computedStyle.borderBottomWidth.replace("px", ""));
            // Add To this object size so the overlay shows the true size of object
            results.styleMinWidth = element.scrollWidth + overlapWidth;
            results.styleMinHeight = element.scrollHeight + overlapHeight;
            // Exclude so that this is not calculated twice for the element holding the object
            results.styleExcludeWidth = element.scrollWidth - overlapWidth;
            results.styleExcludeHeight = element.scrollHeight - overlapHeight;
            //
            // Returns True Left and Top
            //
            var iMarginLeft = Number(computedStyle.marginLeft.replace("px", "")) + Number(computedStyle.borderLeftWidth.replace("px", ""))
                + Number(computedStyle.paddingLeft.replace("px", ""));
            var iMarginTop = Number(computedStyle.marginTop.replace("px", "")) + Number(computedStyle.borderTopWidth.replace("px", ""))
                + Number(computedStyle.paddingTop.replace("px", ""));
            var docElem = element.ownerDocument.documentElement;
            results.offsetTop =  element.offsetTop - docElem.clientTop - iMarginTop;
            results.offsetLeft = element.offsetLeft - docElem.clientLeft - iMarginLeft;
            return results;
        }
        //
        // Get Mouse Position
        //
        // Position on Document Clicked.  This needs to be translated by the click
        _positionClicked(e){
            var temp = this._getMousePosition(e);
            this.coordsClicked = {clientX: temp.x, clientY: temp.y};
        }
        _getMousePosition(e){
            var t,n;
            return e.pageX||e.pageY?(t=e.pageX,n=e.pageY):
                (e.clientX||e.clientY)&&(t=e.clientX+document.body.scrollLeft+document.documentElement.scrollLeft,
                    n=e.clientY+document.body.scrollTop+document.documentElement.scrollTop),
                {x:t,y:n}
        }
        //
        // If Elements are altered external (not dragged) then update so that overlays move correctly.
        //
        _EventRefreshOverlays() {
            var i;
            for (i = 0; i < this.selectedElements.length; ++i) {
                // Object inside - Can expand beyond its borders
                var elementNode = this.selectedElements[i].element.$.node;
                // Polymer Object
                var element = this.selectedElements[i].element;
                // Overlay
                var overlay = this.selectedElements[i].overlay;
                // Quick Sanity Check....
                if (element) {
                    // Element has been moved...
                    var data = { left: parseInt(element.style.left, 10),
                        top: parseInt(element.style.top, 10),
                        width: parseInt(element.style.width, 10),
                        height: parseInt(element.style.top, 10)};
                    // Calculate the real size of the node
                    var cr = this.getComputedStyleResults(elementNode);
                    // Update Overlay
                    this._updateStylePositionSize(overlay,cr.offsetLeft + data.left, cr.offsetTop + data.top,cr.styleMinWidth,cr.styleMinHeight);
                    // Update Data - Main value here is the Min Height and Width
                    this._updateGlyphPositionSize(this.selectedElements[i].element,data.left, data.top, cr.minWidth,cr.minHeight);
                }
            }
            if (this.selectedElements.length === 1) {
                // Fire Event Back - To update Property Editor
//                this.fire('edit-Element', this.selectedElements,"",this.coordsClicked);
            }
        }
        //
        // Refocus Event.
        //
        _EventRefocus(event) {
            var _this = this;
            // Delete All Current Selected Items
            this.blur();
            if (event.detail != null) {
                Array.prototype.forEach.call(event.detail.detail , function(el, i){
                    _this.focus(el,false);
                });
            }
            this._EventRefreshOverlays();
        }
        //
        // Process Key Events
        //
        _EventKeys(event) {
            // Two events - ESC cancels selection.  CTRL-Z fires undo.
            if (this.enable) {
                var e = event || window.event;
                if ((e.keyCode == 90) && (e.ctrlKey)) {
                    // Ctrl - Z - Undo
                    this.fire('edit-UndoStep', null);
                } else if (e.keyCode == 27) {
                    // Escape - Deselect
                    this.selectedElements = [];
                    this.fire('edit-Cancel');
                }
            }
        }
    }
    customElements.define(PaperDragDrop.is, PaperDragDrop);
</script>
